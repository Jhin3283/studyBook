# 클라이언트 - 서버 아키텍쳐
2티어 아키텍쳐 - 리소스가 존재하는 곳(서버)과 리소스를 사용하는 앱(클라이언트)을 분리시킨 것. 클라이언트-서버 아키텍쳐라고 불림.
데이터베이스 - 리소스를 저장하는 공간
- 2티어 아키텍처에 데이터베이스가 추가되면 3티어 아키텍처가 됨
프로토콜 - 통신규약
- 웹 어플리케이션 아키텍처에서 클라이언트와 서버가 서로 HTTP라는 프로토콜을 이용해 메시지를 주고 받고 이를 HTTP 메시지 라고 부름.
주요 프로토콜
1. HTTP - 웹에서 HTML,JSON 등의 정보를 주고받는 프로토콜
2. HTTPS - HTTP에서 보안이 강화된 프로토콜
3. FTP - 파일 전송 프로토콜
4. SMTP - 메일을 전송하기 위한 프로토콜
5. SSH - CLI환경의 원격 컴퓨터에 접속하기 위한 프로토콜
6. RDP - Windows계열의 원격 컴퓨터에 접속하기 위한 프로토콜
7. WebSoket - 실시간 통신, Push 등을 지원하는 프로토콜
8. TCP - HTTP,FTP 통신의 근간이 되는 인터넷 프로토콜
9. UDP - 양방향TCP와 다르게 단방향으로 작동하는 단순하고 빠르지만, 신리성이 낮은 인터넷 프로토콜
API - 서버에서 클라이언트에게 리소스를 잘 활용할수 있도록 제공하는 인터페이스

# URL과 URI
URL - 네트워크 상에서 웹페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타냄. URL은 scheme, hosts, url-path로 구분.
scheme - 통신 방식(프로토콜)을 결정. 일반적으로 http(s)
hosts - 웹 서버 이름,도메인,IP를 사용하고 주소를 나타냄
url-path - 웹 서버에서 지정한 루트 디렉토리부터 시작하는 웹페이지, 이미지, 동영상 등이 위치한 경로와 파일명 나타냄
URI - URL의 기본요소 scheme, hosts, url-path에 더해 query, bookmark를 포함.
query - 웹 서버에 보내는 추가적인 질문
- 브라우저 검색창에 나타나는 주소가 URI이고, URL을 포함하는 상위개념임.

# IP와 PORT
IP - 인터넷상에서 사용하는 주소체계. 네덩이의 숫자로 구분되는 IP주소체계를 IPv4라고 하고, `nslookup URL`를 이용해서 IP주소 확인가능.
PORT - IP주소가 가리키는 PC에 접속할 수 있는 통로(채널)
자주사용하는 포트
22 : SSH
80 : HTTP
443 : HTTPS

# 도메인과 DNS
Domain name - IP주소를 대신해 사용하는 주소. 모든PC는 IP주소가 있지만, 도메인 이름을 가지는것은 아님.
DNS - 호스트의 도메인 주소를 IP주소로 변환하거나 반대의 경우를 수행하는 데이터베이스 시스템

# HTTP
HTTP Message - 클라이언트와 서버 사이에서 데이터가 교환되는 방식
- HTTP message 유형은 요청(Requests)과 응답(Responses) 두 가지 유형이 있음.
- 요청과 응답의 유사한 구조
1. start line - 요청이나 응답의 상태를 나타냄. 항상 첫줄에 위치하고, 응답에서는 status line이라 부름
2. HTTP headers - 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합
3. empty line - 헤더와 본문을 구분하는 빈줄
4. body - 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함. 요청과 응답의 유형에 따라 선택적 사용
- start line과 HTTP headers를 묶어 요청혹은 응답의 헤드라고 하고, payload는 body라고 함.
- HTTP의 가장 큰 특징은 Stateless(무상태성)이다. 

# 요청(Requests)
- start line의 세 가지 요소
1. 수행할 작업(GET, PUT, POST등)이나 방식(HEAD or OPTIONS)를 설명하는 HTTP method를 나타냄
2. 요청 대상 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성. 요청 형식은 hTTP method마다 다름
+ origin 형식 : `?`와 쿼리 문자열이 붙는 절대 경로임. POST, GET, HEAD, OPTIONS등의 메소드와 함께 사용. ex)`POST / HTTP 1.1`
+ absolute 형식 : 완전한 URL 형식 프록시에 연결하는 경우 대부분 GET method와 함께 사용. ex) `GET http://developer.mozilla.org/en-US/docs/Web/HTTP/MessagesHTTP/1.1`
+ authority 형식 : 도메인 이름과 포트 번호로 이루어진 URL의 authority component임. HTTP 터널 구축시, CONNECT와 함께 사용. ex) `CONNECT developer.mozilla.org:80 HTTP/1.1``
+ asterisk 형식 : OPTIONS와 함께 별표(*) 하나로 서버 전체를 표현. ex) `OPTIONS * HTTP/1.1``
3. HTTP 버전에 따라 HTTP message의 구조가 달라지기 때문에, start line에 HTTP 버전을 함께 입력함.
- Headers -> 요청의 Headers는 기본 구조를 따름. 헤더 이름(대소문자 구분이 없는 문자열),콜론(:),값을 입력하고, 값은 헤더에 따라 다름.
+ General headers : 메시지 전체에 적용되는 헤더로, body를 통해 전송되는 데이터와는 관련없는 헤더임.
+ Request headers : fetch를 통해 가져올 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더
+ Representation headers : body에 담긴 리소스의 정보(컨텐츠 길이, MiME 타입 등)를 포함하는 헤더
- Body -> 요청의 본문은 HTTP messages 구조의 마지막에 위치함. 모든요청에 body가 필요하지는 않음. GET,HEAD,DELETE,OPTIONS처럼 서버에 리소스 요청하는 경우 본문이 필요하지 않음. POST, PUT과 같은 일부 요청은 데이터를 업데이트하기 위해 사용.
+ Single-resource bodies : 헤더 두개로 정의된 단일 파일로 구성
+ Multiple-resource bodies : 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지님.

# 응답(Responses)
- Status line -> 응답의 첫줄을 말하며, 현재 프로토콜의 버전, 상태 코드(요청의 결과), 상태 텍스트(상태 코드설명)등의 정보를 포함.
- Headers -> 응답의 HTTP headers는 요청 헤더와 동일한 구조를 가짐.
- Body -> 응답의 본문은 HTTP messages 구조의 마지막에 위치. 모든 응답에 body가 필요하지 않음.
- 응답의 body의 두종류
1. Single-resource bodies : 길이가 알려진 단일-리소스 본문은 두 개의 헤도로 정의하고, 길이를 모를경우, Transfer-Encoding이 chunked로 설정되어 있으며, 파일은 chunk로 나뉘어 인코딩 되어 있음.
2. Multiple-resource bodies : 서로 다른 정보를 담고 있는 body
# AJAX
AJAX - JavaScript,DOM,Fetch,XMLHttpReqest,HTML등 다양한 기술을 사용하는 웹 개발 기법. 가장 큰 특징은 웹 페이지에 필요한 부분에 필요한 데이터만 비동기적으로 받아옴.
- AJAX를 구성하는 핵심 기술은 JavaScript, DOM, Fetch
- Fetch를 사용하여 페이지를 이동하지 않고 서버로부터 필요한 데이터를 받아올 수 있음. 계속해서 페이지를 사용할수 있게 비동기적인 방식을 사용.
- AJAX의 장점
1. 서버에서 HTML을 완성하여 보내주지 않아도 웹페이지를 만들수 있음. 
2. 브라우저에 상관 없이 AJAX를 사용가능.
3. 필요한 일부분만 렌더링해서 더 많은 상호작용이 가능하게 웹페이지를 만들수 있음.
4. 필요한 데이터를 텍스트 형태로 보내면 되서 비교적 데이터의 크기가 작음.
- AJAX의 단점
1. AJAX 방식의 웹 어플리케이션은 한번 받은 HTML을 렌더링한 후, 서버에서 비동기적으로 필요한 데이터를 가져오기 때문에 SEO에 불리하고, 검색 사이트에서 사용하기 힘듬.
2. AJAX에서는 이전 상태를 기억하지 않기 때문에 뒤로가기등의 기능을 구현하기 위해서는 별도 History API를 사용해야함.

# SSR과 CSR
SSR - 웹 페이지를 브라우저에서 렌더링하는 대신에 서버에서 렌더링하는 것. 웹페이지의 내용에 데이터베이스의 데이터가 필요한 경우, 서버는 데이터베이스의 데이터를 불러온 다음 웹페이지를 완전히 렌더링된 페이지로 변환후에 브라우저에 응답을 보냄. 
CSR - 일반적으로 SSR의 반대로, 클라이언트에서 페이지를 렌더링함.  브라우저의 요청을 서버로 보내면 서버는 웹 페이지의 골격이 될 단일 페이지를 클라이언트에 보내고, 서버는 웹 페이지와 함께 JavaScript 파일을 보내게 됨. 클라이언트가 웹 페이지를 받으면, 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꿈. 브라우저는 API를 사용하여, 데이터베이스에 저장된 데이터를 가져와서 웹페이지에 렌더링함.
+ CSR과 SSR의 차이
- 주요 차이점은 페이지가 렌더링되는 위치이고, 브라우저는 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침하지 않고, 동적으로 라우팅을 관리함.
SSR 사용하는 경우
1. SEO가 우선순위인 경우
2. 웹페이지의 첫 화면 렌더링이 빠르게 필요한 경우
3. 웹 페이지가 사용자와 상호작용이 적은 경우
CSR 사용하는 경우
1. SEO가 우선순위가 아닌경우
2. 사이트에 풍부한 상호 작용이 있는 경우
3. 웹 어플리켕션을 제작하는 경우

# CORS
CORS - 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청됨.

# REST API
Rest API - 웹에서 사용되는 데이터나 자원을 HTTP URI로 표현하고, HTTP프로토콜을 통해 요청과 응답을 정의하는 방식
- 좋은 REST API 디자인하는법
1. 0단계 - HTTP 프로토콜 사용
2. 1단계 - 개별 리소스와의 통신을 준수해야함. 모든 자원은 개별 리소스에 맞는 엔드포인트를 사용해야 하고, 요청하고 받은 자원에 대한 정보를 응답으로 전달해야함.
3. 2단계 - CRUD에 맞게 적절한 HTTP 메소드를 사용. 
- 메소드 사용규칙
> GET 메소드는 서버의 데이터를 변화시키지 않는 요청에 사용
> POST는 요청마다 새로운 리소스를 생성하고 PUT은 요청마다 같은 리소스 반환. PUT은 멱등성가짐 POST는 안가짐.
> PUT과 PATCH도 구분해서 사용. PUT은 교체, PATCH는 수정의 용도로 사용
4. 3단계 - 여기까지는 안지켜져도 됨. 응답에는 리소스의 URI를 포함한 링크 요소를 삽입하여 작성
