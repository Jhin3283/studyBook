# 변수

프로그래밍은 데이터 처리를 하는것인데, 변수사용은 데이터를 편리하게 저장하고 꺼내 쓰는 것이다.
변수의 선언과 할당

```js
let A = 1;
```

변수명의 규칙-camel Case, 동일한 변수를 이용해 대입가능
변수를 선언만 하고 할당하지 않은 경우 undefined

# 함수

함수는 작은기능의 단위이다. 함수는 항상 출력값을 반환한다.
함수 선언 방법
함수 선언식

```js
function getSum(num1, num2) {
  let sum = num1 + num2;
  return sum;
}
```

함수 표현식

```js
const getSum = function (num1, num2) {
  let sum = num1 + num2;
  return sum;
};
```

화살표 함수

```js
const getSum = (num1, num2) => {
  let sum = num1 + num2;
  return sum;
};
```

만약 함수의 본문에 return문만 있는경우, return과 중괄호 생략가능

```js
const getSum =(num1,num2) =>
    num1 + num2
}
```

함수의 선언에서 사용된 변수는 매개변수(parameter)이고, 호출에서 매개변수에 할당된 값 전달인자(argument)라고 한다.

# 조건문

조건문은 어떠한 조건을 판별하는 기준을 만드는것 으로, 비교 연산자가 필요하다.

> ,<,===,!== 등으로 비교가 가능하고,비교의 결과는 늘 Boolean값이 된다.

```js
let A = 0;
if (A === "0") {
  return "bad";
} else if (A === 0) {
  return "good";
} else {
  return "bad";
}
```

And 연산자 - &&
OR 연산자 - ||
NOT 연산자 - !
6가지 falsy 값
false, null, undefined, 0, NaN, ''

# 문자열

- index로 접근은 가능하지만 쓸수는 없음
- +연산자 사용가능 -연산자는 불가 +연산자 사용할 경우, string 형식으로 변환됨
  str.indexOf(value) - value값의 인덱스 찾아주는 내장함수
  str.split(value) - value값을 기준으로 문자열을 분리해서 배열로 리턴하는 내장함수
  모든 string method는 immutable

# 반복문

같거나 비슷한 코드를 여러 번 실행시켜야 할때 사용하는 구문
for 구문 - 초기화, 조건식, 증감문 순으로 넣어줌

```js
let sum = 1;
for (let i = 1; i <= 4; i++) {
  sum += i;
}
```

while 구문 - 초기화,증감문은 따로, 조건식만 괄호에 넣어서 사용

```js
let sum = 1;
let i = 1;
while (i <= 4) {
  sum += i;
  i++;
}
```

<<<<<<< HEAD

# 배열

=======

# 배열

> > > > > > > 92fc9017d508a73c662857f68667eeedd369928d

배열 - 순서가 있는 값. 순서는 인덱스이고 0부터 시작. 대괄호`[]`이용 배열 만들고, 각 원소 쉼표로 구분. 값은 인덱스로 접근. dot`.`을 이용해 속성에 접근
배열메소드
.length - 배열의 길이
.push(el) - 배열끝에 추가
.pop() - 배열마지막값 삭제
.Array.isArray - 배열인지 아닌지 판별
.indexOf(el) - 배열 내 요소의 최초 인덱스. 없으면 -1출력
.includes(el) - 배열 내 요소를 포함하는지 판별. Boolean값 출력

# 객체

객체 - 키와 값으로 구성된 property의 정렬되지 않은 집합. 중괗로`{}`이용 객체 만들고, 키-값 쌍은 쉼표로 구분.
객체의 값 사용방법

1. Dot notation - user.city; // 'busan' => dot`.`을 이용
2. Bracket notation - user['city']; // 'busan' => `[]`안에 문자열로 넣어야함. 문자열로 안넣으면 변수로 취급됨.
   delete - 삭제 가능 ex) delete user.city or user['city']

# 원시자료형

원시 타입의 데이터 - 객체가 아니면서 method를 가지지 않는 6가지. `string, number,bigint, boolean, undefined, symbol, (null)`
원시자료형은 모두 하나의 데이터를 담고 있음
변수에는 하나의 데이터만 담을수 있음. 원시 자료형의 값 자체는 immutable이지만, 변수에 다른 데이터 할당 가능

# 참조자료형

참조 자료형 - 원시 자료형이 아닌 모든 것. 배열,객체,함수가 대표적.
참조 자료형은 데이터 여러개가 담기게 됨. 데이터가 위치한 곳 주소가 변수에 저장됨

# 원시자료형과 참조자료형 특징

1. 원시 자료형이 할당은 변수에 값(value) 자체가 담기고, 참조 자료형이 할당은 보관함의 주소(reference)가 담김
2. 참조 자료형은 고정된 크기의 보관함이 아니라, 동적으로 크기가 변하는 특별한 보관함을 사용가능

# 스코프

스코프 - 변수 접근 규칙에 따른 유효 범위
스코프 규칙

1. 안쪽 스코프에서 바깥쪽 스코프로는 접근할 수 있지만 반대는 불가능
2. 스코프는 중첩이 가능함
3. 가장 바깥쪽의 스코프는 전역 스코프라고 하고, 전역외의 스코프를 지역 스코프라고함. 지역 스코프에 선언한 변수 지역변수, 전역 스코프에 선언한 변수 전역변수
4. 지역 변수는 전역 변수보다 높은 우선순위를 가짐
   스코프의 종류
5. 블록 스코프 - 중괄호`{}`를 기준으로 범위 구분. 화살표 함수는 블록 스코프임.
6. 함수 스코프 - 함수로 둘러싼 범위. function키워드이용하는 함수 선언식 및 함수 표현식만 적용.
   let - 블록 스코프만 따름. 재선언 방지. 블록 단위로 스코프 구분할때, 예측 가능한 코드작성 용이. 재선언 불가능.
   var - 블록 스코프 무시(화살표 함수는 무시X). 함수 스코프만 따름. 재선언 불가능.
   const - 블록 스코프만 따름. 변하지 않는 값(상수) 정의에 이용. 재할당 불가능. 재선언 가능.
   변수선언 주의할점
7. Window 객체 - 브라우저의 창(Window) 의미하는 객체. var로 선언된 전역 및 지역변수는 window객체에 속함.
8. 전역변수는 최소화 - 전역변수에 너무 많은 변수를 선언하면, 다른 함수 혹은 로직에 의해 의도치 않게 변경될수 있음(Side effect).
9. 전역변수를 var로 선언할 경우 브라우저의 내장 기능을 이용할수 없을수 있음. let,const를 주요 사용할것.
10. 선언 없는 변수 할당 금지 - 선언없이 변수 할당할 경우, 해당 변수를 var로 선언한 전역 변수처럼 취급.
11. Strict Mode - 브라우저가 엄격하게 작동하게됨. js파일 상단에 `'use strict'`입력해서 적용.

# 클로저

클로저 - 함수와 함수가 선언된 어휘적 환경의 조합.
클로저함수 - 함수를 리턴하는 함수.
클로저는 리턴하는 함수에 의해 스코프가 구분됨. 외부함수, 내부함수
내부함수는 외부 함수에 선언된 변수에 접근 가능. 역으로는 불가능.
클로저는 외부 함수 실행이 끝나도, 외부 함수 내 변수 사용 가능.
클로저를 이용해 객체에 담은 여러개의 내부 함수 리턴할수 있음.

# Spread 문법

Spread - 배열을 풀어서 인자로 전달하거나, 각각의 요소로 넣을때 사용.
배열에서 사용법

1. 배열 합치기
2. 배열 복사
   Reset - 파라미터를 배열의 형태로 받아서 사용가능.

# 고차 함수

고차 함수 - 함수를 인자로 받을 수 있고, 함수의 형태로 리턴할 수 있는 함수.
콜백 함수 - 다른 함수의 인자로 전달되는 함수. 콜백 함수를 전달받은 고차 함수는 함수 내부에서 콜백 함수 호출 할 수 있음(호출하지 않을 수도 있고, 여러번 실행도 가능).
내장 고차함수

1. filter - 배열의 요소 중에서 특정 요건 만족하는 요소 걸러내는 메소드. 특정 조건은 함수의 형태이고, filter 메소드의 인자로 전달됨.
2. map - 하나의 데이터를 다른 데이터로 맵핑할 때 사용.
3. reduce - 여러 데이터를 하나의 데이터로 응축할 때 사용.

# OOP(객체 지향 프로그래밍)

OOP - Object-oriented programming의 약자로 절차 지향 프로그래밍과 다르게 데이터와 기능을 한 곳에 묶어서 처리.

- 클래스를 바탕으로 인스턴스 객체를 만드는 프로그래밍 패턴
- 클래스를 함수로 정의하는데 일반적인 함수와 차이를 두기 위해 클래스는 대문자,일반명사로 만듬. <-> 일반적인 함수는 적절한 동사 소문자로 시작하면 좋음
- ES6에서 function 대신 class키워드를 사용해 만들수 있고, 이를 생성자(constructor)함수 라고 부름. 생성자 함수에서는 리턴값을 만들지 않음.
- 인스턴스를 만들때는 new키워드를 사용. 각각의 인스턴스는 클래스의 고유한 속성과 메소드를 가짐
  this - 인스턴스 객체를 의미. 만들어진 객체에 해당 속성을 부여하는 역활.
  메소드 - ES6에서 생성자 함수랑 class키워드 안쪽에 묶어서 정의.

객체 지향 프로그래밍 기본 컨셉

1. 캡슐화 - 속성과 메소드를 하나의 단위로 묶어서 느슨한 결합. 내부 속성과 메소드가 외부로 노출되지 않는 은닉화.

- 장점: 코드가 복잡하지 않게 하고, 재사용성을 높임.
  느슨한 결합 - 코드가 상징하는 실제 모습과 닯게 코드를 결합하는 것

2. 상속 - 부모 클래스의 특징을 자식 클래스가 물려받는 것

- 장점: 불필요한 코드를 줄여 재사용성 높임

3. 추상화 - 내부 구현은 복잡하지만, 외부에 노출되는 부분은 단순하게 만드는 것.

- 장점: 코드가 복잡하지 않게 하고, 단순화된 사용으로 변화에 대한 영향 최소화
  인터페이스 - 클래스 정의시, 메소드와 속성만 정의한 것. 추상화의 본질.
  캡슐화와 추상화의 차이 - 캡슐화는 은닉에 포커스. 추상화는 사용자에게 필요하지 않은 메소드 노출시키지 않고, 단순한 이름으로 정의하는 것에 포커스

4. 다형성 - 다양한 형태를 가질수 있는 것

- 장점: 동일한 메소드에 대해 if/else if와 같은 조건문 대신 객체의 특성에 맞게 작성 가능

# 프로토타입

프로토타입 - 원형 객체

- JavaScript는 객체를 상속하기 위해 프로토타입 방식을 사용. JavaScript는 프로토타입 기반 언어이고, 모든 객체들이 메소드와 속성을 상속받기 위해 프로토타입 객체를 가짐.
- ex) Human이라는 클래스와 인스턴스가 있을때,
  Human -> `.prototype` -> Human.prototype.sleep -> `new Human();(instance)` -> steve.sleep
  steve.sleep -> `.__proto__`-> Human.prototype.sleep -> `.constructor`-> Human
  프로토타입 체인 - 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례로 검색하는 것. 객체 지향 프로그래밍의 특성 중 상속을 JavaScript에서 구현할 때 사용함. 다른 객체에 정의된 속성과 메소드를 한 객체에서 사용함의 근간.
  상속 - 속성과 메소드를 물려주는 클래스(부모 클래스)와 받는 클래스(자식 클래스) 이 과정을 말함. JavaScript에서는 extends와 super 키워드로 상속 구현.

# 비동기

callback - 다른 함수A의 전달인자로 받는 함수B
비동기 - parameter를 넘겨받는 함수A는 callback 함수 B를 즉시 실행(synchronously)할수 있고, 나중에 실행((asynchronously)) 할수있음 이때, 나중에 실행하는 것이 비동기 임. ex) sync - 하던일을 멈추고 해야함(전화) => 요청과 동시에 결과가 동시에 일어남. <=> async - 나중에 해도됨(문자) => 요청의 결과가 동시에 일어나지 않음.

- async의 순서제어를 callback을 이용해서 함.
- Promise에서 `.then`을 이용해서 순서제어가 가능하고, `.catch`를 통해 에러를 잡을수 있음.
- Promise에서 async/await로 비동기 처리 가능.

# 타이머 API

setTimeout(callback, millisecond) - 일정시간 후 함수 실행. arguments: 콜백함수, 콜백함수 실행 전 기다려야 할 시간. return value: 임의의 타이머ID
setInterval(callback, millisecond) - 일정시간의 간격을 가지고 함수를 반복적으로 실행. arguments: 콜백함수, 반복적으로 함수를 실행시키는 시간 간격. return value: 임의의 타이머ID
clearInerval(timerId) - 반복 실행중인 타이머를 종료. arguments: timerId. return value: 없음.
